# aki-mcolor: Design Specification

## 1. Introduction

This document describes the internal design of the `aki-mcolor` command-line utility. It explains how the components of the source code in the `src` directory work together to satisfy the requirements and acceptance criteria defined in `specs/1.acceptance-criteria.md`.

The design prioritizes modularity, testability, and efficient stream processing.

## 2. High-Level Architecture

The application follows a standard pipeline architecture for a CLI tool. The flow is as follows:

1.  **Initialization**: The `main` function in `main.rs` serves as the entry point. It collects command-line arguments and prepares the I/O environment using the `runnel` crate.
2.  **Delegation to Library**: `main` delegates control to the `execute` function in the `libaki_mcolor` library crate, passing the arguments and I/O handles.
3.  **Configuration**: The `execute` function calls the `conf` module to parse command-line arguments and read environment variables. This produces two configuration structs: `CmdOptConf` for arguments and `EnvConf` for color sequences.
4.  **Execution**: The configuration objects are passed to the `run::run` function, which contains the core logic.
5.  **Stream Processing**: The `run` module reads from standard input line by line. For each line, it applies the coloring rules.
6.  **Output**: The processed line, now with ANSI color codes, is written to standard output.
7.  **Termination**: Once the input stream is exhausted, the program exits. Errors are propagated using `anyhow::Result` and handled in `main`, which sets the process exit code.

This can be visualized as:
`main.rs` -> `lib.rs::execute()` -> `conf::parse_cmdopts()` -> `run::run()` -> `run::do_match_proc()`

## 3. Component Breakdown

The codebase is divided into several modules, each with a distinct responsibility.

### 3.1. `main.rs` - Application Entry Point

- **Purpose**: To handle process-level concerns and act as a thin launcher for the library crate.
- **Responsibilities**:
    - Collects arguments from `std::env::args()`.
    - Sets up a standard I/O environment (`stdin`, `stdout`, `stderr`) using `RunnelIoeBuilder`.
    - Calls `libaki_mcolor::execute` to run the core logic.
    - Catches and prints any propagated `anyhow::Error` to `stderr`.
    - Sets the process exit code (`0` for success, `1` for failure).

### 3.2. `lib.rs` - Core Library

- **Purpose**: To decouple the main logic from the binary executable, making it a reusable library.
- **Responsibilities**:
    - Provides the public `execute()` function, which is the primary entry point for the library.
    - Orchestrates the main sequence: create `EnvConf`, call `parse_cmdopts`, and if successful, call `run::run`.
    - Handles special exit conditions for `--help` and `--version` by inspecting the parsing result without treating it as a fatal error.

### 3.3. `conf` Module - Configuration Management

- **Purpose**: To parse and validate all user-provided configuration.
- **Key Data Structures**:
    - `CmdOptConf`: A struct that holds the parsed command-line arguments. The vectors like `opt_red: Vec<String>` store the regex patterns provided by the user. This is populated by the `flood-tide` crate.
    - `EnvConf`: Holds the ANSI escape code sequences for colors. It reads these from `AKI_MCOLOR_*` environment variables or uses hardcoded defaults. This directly addresses **AC15-AC21**.
    - `Color`: An enum (`Red`, `Green`, etc., plus `None`) used internally to represent the color state.
- **Logic**:
    - `parse_cmdopts()`: Implements the CLI specification (**AC4-AC10**, **AC12**, **AC13**). It uses `flood-tide` to define and parse arguments. It enforces the rule that at least one color option must be present, satisfying **AC14**.

### 3.4. `run.rs` - Core Processing Logic

- **Purpose**: To implement the primary text-coloring algorithm.
- **Key Data Structures**:
    - `ColorAndRegex`: A runtime struct that pairs a compiled `regex::Regex` with a `Color` enum.
- **Algorithm**:
    1.  **Regex Compilation**: The `run` function first transforms the string patterns from `CmdOptConf` into a `Vec<ColorAndRegex>`. This pre-compiles all regular expressions for efficient use.
    2.  **Line-by-Line Processing**: `do_match_proc` reads the input stream one line at a time, fulfilling the stream processing requirement.
    3.  **Color Marking**: For each line, the `do_match_proc_0` function executes the core algorithm:
        a. A `Vec<Color>` named `line_color_mark` is created with the same length as the line, acting as a character-by-character coloring buffer.
        b. It iterates through the `ColorAndRegex` vector. For each regex, it finds all matching segments in the line.
        c. For each match, it updates the corresponding range in the `line_color_mark` buffer with its color. This overwrites any previous color in that range, naturally satisfying the precedence requirement (**AC11**).
    4.  **Output Reconstruction**: After all regexes are processed, the code iterates through the `line_color_mark` buffer. It builds the final output string by appending the correct ANSI color-start sequence, the text slice, and the color-end sequence whenever the color changes.
    5.  **Passthrough**: If no matches are found for a line, the `b_found` flag remains false, and the original line is written to output, satisfying **AC2**.

### 3.5. `util` Module - Shared Utilities

- **Purpose**: To provide small, reusable pieces of code.
- **`err.rs`**: Contains the `BrokenPipeError` trait. This allows the application to check for `std::io::ErrorKind::BrokenPipe` and exit gracefully, satisfying **AC3**.

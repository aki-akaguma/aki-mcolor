# aki-mcolor: Development Tasks

This document lists the development tasks required to build the `aki-mcolor` utility, based on the design specification. All tasks are marked as complete, reflecting the current state of the codebase.

## Phase 1: Project Scaffolding and Core Structure

- [x] Initialize a Rust project with a library (`lib.rs`) and a binary (`main.rs`) crate.
- [x] Integrate `anyhow` for ergonomic error handling throughout the application.
- [x] Integrate `runnel` to abstract standard input/output streams.
- [x] Set up the basic module structure (`conf`, `run`, `util`).

## Phase 2: Configuration and Argument Parsing

- [x] **(conf)** Implement command-line argument parsing using the `flood-tide` crate.
- [x] **(conf)** Define and parse all color options (`--red`, `--green`, `--blue`, `--cyan`, `--magenda`, `--yellow`).
- [x] **(conf)** Define and parse the `--unmark` option.
- [x] **(conf)** Implement the `--help` and `--version` flags and their corresponding exit behavior.
- [x] **(conf)** Add validation to ensure at least one color or unmark option is provided by the user.
- [x] **(conf)** Implement the `EnvConf` struct to manage custom ANSI color sequences.
- [x] **(conf)** Add logic to read `AKI_MCOLOR_*` environment variables, with hardcoded defaults as a fallback.

## Phase 3: Core Coloring Logic

- [x] **(run)** Create the `ColorAndRegex` struct to hold compiled regular expressions and their associated colors.
- [x] **(run)** Implement the initial logic to compile regex patterns from the configuration.
- [x] **(run)** Implement the main processing loop to read from the input stream line by line.
- [x] **(run)** Develop the core coloring algorithm using a `line_color_mark` vector as a buffer for each line.
- [x] **(run)** Ensure the algorithm correctly handles match precedence by overwriting buffer segments (last match wins).
- [x. **(run)** Implement the output reconstruction logic to build the final string with the correct ANSI escape codes.
- [x] **(run)** Ensure that lines with no matches are passed through to the output unmodified.

## Phase 4: Finalization and Error Handling

- [x] **(util)** Create the `BrokenPipeError` utility to allow for graceful exits when the output pipe is closed.
- [x] **(run)** Integrate the `BrokenPipeError` check into the main run loop.
- [x] **(main)** Implement the main application entry point.
- [x] **(main)** Ensure that errors propagated from the library are caught, printed to `stderr`, and result in a non-zero exit code.

## Phase 5: Documentation

- [x] **(specs)** Write the software requirements specification (`0.requirements.md`).
- [x] **(specs)** Write the EARS acceptance criteria (`1.acceptance-criteria.md`).
- [x] **(specs)** Write the design specification (`2.design.md`).
- [x] **(specs)** Create this development task checklist (`3.tasks.md`).
- [x] **(docs)** Add comprehensive `rustdoc` comments to `lib.rs` explaining the tool's usage and features.
